<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NL → 3D Map MVP (Photorealistic 3D Maps)</title>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    .app { height: 100%; display: grid; grid-template-columns: 380px 1fr; }
    @media (max-width: 900px) { .app { grid-template-columns: 1fr; grid-template-rows: 360px 1fr; } }

    .panel { padding: 12px; border-right: 1px solid #ddd; overflow: auto; background: #fafafa; }
    @media (max-width: 900px) { .panel { border-right: none; border-bottom: 1px solid #ddd; } }

    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; }
    button { padding: 10px 12px; border: 1px solid #ccc; background: #fff; border-radius: 10px; cursor: pointer; }
    button.primary { border-color: #222; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    textarea { width: 100%; min-height: 140px; resize: vertical; border-radius: 10px; border: 1px solid #ccc; padding: 10px; }
    .hint { font-size: 12px; color: #555; line-height: 1.6; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .status { padding: 8px 10px; border-radius: 10px; background: #fff; border: 1px solid #ddd; }
    .mapWrap { position: relative; }
    gmp-map-3d { width: 100%; height: 100%; display: block; }
  </style>

  <!-- Maps JS API (v=beta) + maps3d -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=REMOVED&v=beta&libraries=maps3d"
    defer
  ></script>
</head>

<body>
  <div class="app">
    <aside class="panel">
      <h2 style="margin:0 0 8px;">自然言語 → 3Dマップ（超最短MVP）</h2>
      <div class="hint">
        例：<br/>
        ・「レインボーブリッジに赤い危険区域 高さ60m 半透明」<br/>
        ・「東京駅に青い四角 高さ120」<br/>
        ・「渋谷に緑の円 透明度0.2 高さ30」<br/>
        ・「東京タワーに黄色い三角」<br/><br/>
        対応：場所(辞書) / 色 / 形(四角・円・三角) / 高さ / 透明度<br/>
        ※マウス操作なしで生成します。
      </div>

      <div class="row">
        <button id="btnGenerate" class="primary">生成</button>
        <button id="btnFly">Fly</button>
        <button id="btnUndo">Undo</button>
        <button id="btnClear">クリア</button>
        <button id="btnRotate">回転</button>
      </div>

      <textarea id="prompt" placeholder="例：レインボーブリッジに赤い危険区域 高さ60m 半透明"></textarea>

      <div class="row" style="margin-top:8px;">
        <button id="btnExport">JSON出力</button>
        <button id="btnIndividual">個別出力</button>
      </div>

      <textarea id="json" class="mono" placeholder="生成されたJSONがここに出ます"></textarea>

      <textarea id="apiRequest" class="mono" placeholder="Maps JS API への最終リクエスト内容"></textarea>

      <div class="mono" id="templateInfo">使用テンプレ：なし</div>
      <div class="status mono" id="status">Ready</div>
      <div class="hint" style="margin-top:10px;">
        次ステップ（ハッカソン映え）：このJSON生成部分を Gemini / Vertex AI に置き換えるだけ。
      </div>
    </aside>

    <main class="mapWrap">
      <gmp-map-3d id="map3d" mode="hybrid"></gmp-map-3d>
    </main>
  </div>

  <script>    
    let TEMPLATES = null;
    async function loadTemplates() {
      const r = await fetch("./templates.json");
      const j = await r.json();
      TEMPLATES = j.archetypes;
    }

    const $ = (id) => document.getElementById(id);
    const setStatus = (s) => $("status").textContent = s;

    let lastRequest = null; // ←「Maps JS APIに最終的に渡した内容」をここに貯める

    // ---- ルールベース辞書（場所→座標） ----
    const PLACE_DB = [
      { key: /東京駅/, name: "東京駅", lat: 35.681236, lng: 139.767125, heading: 30, tilt: 65, range: 1600 },
      { key: /渋谷/, name: "渋谷", lat: 35.658034, lng: 139.701636, heading: 20, tilt: 65, range: 1500 },
      { key: /レインボーブリッジ|虹の橋/, name: "レインボーブリッジ", lat: 35.6367, lng: 139.8753, heading: 35, tilt: 65, range: 1500 },
      { key: /東京タワー/, name: "東京タワー", lat: 35.658581, lng: 139.745433, heading: 40, tilt: 65, range: 1400 },
      { key: /ディズニー|舞浜/, name: "東京ディズニーリゾート", lat: 35.632896, lng: 139.880394, heading: 10, tilt: 65, range: 1700 },
      { key: /東京ドーム/, name: "東京ドーム", lat: 35.705639, lng: 139.751891, heading: 20, tilt: 65, range: 1400 },
    ];

    // 色（日本語→RGBA）
    const COLOR_DB = [
      { key: /赤|レッド/, rgba: (a)=>`rgba(255,0,0,${a})`, stroke: "#aa0000" },
      { key: /青|ブルー/, rgba: (a)=>`rgba(0,128,255,${a})`, stroke: "#004a99" },
      { key: /緑|グリーン/, rgba: (a)=>`rgba(0,200,80,${a})`, stroke: "#007a33" },
      { key: /黄|黄色|イエロー/, rgba: (a)=>`rgba(255,200,0,${a})`, stroke: "#9a7a00" },
    ];

    // 形
    function detectShape(text) {
      if (/円|まる|サークル/.test(text)) return "circle";
      if (/三角/.test(text)) return "triangle";
      if (/四角|矩形|しかく|ボックス/.test(text)) return "rect";
      // デフォルト
      return "rect";
    }

    // 数値抽出
    function detectHeight(text) {
      // 高さ60m / 高さ 60 / 60m
      const m = text.match(/高さ\s*([0-9]+)\s*m?/);
      if (m) return clampInt(parseInt(m[1],10), 0, 500);
      const m2 = text.match(/([0-9]+)\s*m/);
      if (m2) return clampInt(parseInt(m2[1],10), 0, 500);
      return 60;
    }

    function detectOpacity(text) {
      // 透明度0.2 / opacity 0.4 / 半透明
      const m = text.match(/透明度\s*([0-9.]+)/);
      if (m) return clamp01(parseFloat(m[1]));
      const m2 = text.match(/opacity\s*([0-9.]+)/i);
      if (m2) return clamp01(parseFloat(m2[1]));
      if (/半透明/.test(text)) return 0.35;
      if (/不透明/.test(text)) return 0.85;
      return 0.35;
    }

    function hexToRgba(hex, a) {
      const m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(hex);
      if (!m) return `rgba(255,0,0,${a})`;
      const r = parseInt(m[1], 16);
      const g = parseInt(m[2], 16);
      const b = parseInt(m[3], 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    function detectPlace(text) {
      for (const p of PLACE_DB) {
        if (p.key.test(text)) return p;
      }
      return null; // ← 分からない場合は null
    }

    function detectColor(text) {
      for (const c of COLOR_DB) if (c.key.test(text)) return c;
      // デフォルト：青系
      return { rgba:(a)=>`rgba(0,170,255,${a})`, stroke:"#006b88" };
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function clampInt(n, min, max) { return Math.max(min, Math.min(max, n)); }

    // ---- 図形生成（中心座標から簡易ポリゴン生成）----
    // rect: 緯度経度に対して小さなオフセットを四隅に与える
    function makeRect(center, meters=250) {
      const dLat = metersToLat(meters);
      const dLng = metersToLng(meters, center.lat);
      return [
        { lat: center.lat + dLat, lng: center.lng - dLng },
        { lat: center.lat + dLat, lng: center.lng + dLng },
        { lat: center.lat - dLat, lng: center.lng + dLng },
        { lat: center.lat - dLat, lng: center.lng - dLng },
      ];
    }

    function offsetCenter(center, dxMeters, dyMeters) {
      return {
        lat: center.lat + metersToLat(dyMeters),
        lng: center.lng + metersToLng(dxMeters, center.lat),
      };
    }

    function makeTriangle(center, meters=300) {
      const dLat = metersToLat(meters);
      const dLng = metersToLng(meters, center.lat);
      return [
        { lat: center.lat + dLat, lng: center.lng },
        { lat: center.lat - dLat, lng: center.lng - dLng },
        { lat: center.lat - dLat, lng: center.lng + dLng },
      ];
    }

    // circleは多角形近似（N角形）
    function makeCircle(center, meters=260, n=18) {
      const pts = [];
      for (let i=0;i<n;i++){
        const t = (Math.PI*2*i)/n;
        const dx = Math.cos(t)*meters;
        const dy = Math.sin(t)*meters;
        const lat = center.lat + metersToLat(dy);
        const lng = center.lng + metersToLng(dx, center.lat);
        pts.push({ lat, lng });
      }
      return pts;
    }

    function makeNgon(center, meters = 260, sides = 6) {
      const n = Math.max(3, Math.min(48, Math.round(sides)));
      const pts = [];
      for (let i = 0; i < n; i++) {
        const t = (Math.PI * 2 * i) / n;
        const dx = Math.cos(t) * meters;
        const dy = Math.sin(t) * meters;
        const lat = center.lat + metersToLat(dy);
        const lng = center.lng + metersToLng(dx, center.lat);
        pts.push({ lat, lng });
      }
      return pts;
    }

    // ざっくり変換（精密ではないがMVPには十分）
    function metersToLat(m){ return m / 111_320; }
    function metersToLng(m, lat){ return m / (111_320 * Math.cos(lat * Math.PI/180)); }

    function parseMetersFromText(text) {
      // 半径500m / 500m / 1km などを拾う（最優先）
      const km = text.match(/([0-9]+(?:\.[0-9]+)?)\s*km/i);
      if (km) return Math.round(parseFloat(km[1]) * 1000);

      const m = text.match(/([0-9]+(?:\.[0-9]+)?)\s*m/i);
      if (m) return Math.round(parseFloat(m[1]));

      const han = text.match(/半径\s*([0-9]+(?:\.[0-9]+)?)\s*m?/);
      if (han) return Math.round(parseFloat(han[1]));

      return null;
    }

    function pickMeters(spec, originalText) {
      // 1) specが数値を返したら最優先
      if (Number.isFinite(spec?.radius) && spec.radius > 0)
        return Math.max(30, spec.radius);

      if (Number.isFinite(spec?.meters) && spec.meters > 0)
        return Math.max(30, spec.meters);

      // 2) 念のため、元テキストからも拾う（AIが落としても大丈夫に）
      const t = parseMetersFromText(originalText);
      if (Number.isFinite(t)) return Math.max(30, t);

      // 3) size マッピング
      const size = String(spec?.size ?? "medium").toLowerCase();
      if (size === "small") return 160;
      if (size === "large") return 450;
      return 260; // medium
    }

    // ---- maps3d描画 ----
    let map3d, Polygon3DElement, AltitudeMode;
    // let rendered = []; // 生成したポリゴンを保持（クリア用）
    let renderedGroups = [];
    let currentGroup = null; // ★追加：今の生成グループ

    window.addEventListener("load", async () => {
      try {
        await loadTemplates();

        ({ Polygon3DElement, AltitudeMode } =
          await google.maps.importLibrary("maps3d"));

        await customElements.whenDefined("gmp-map-3d");
        map3d = $("map3d");

        // 初期位置
        const p = PLACE_DB[0];
        map3d.center = { lat: p.lat, lng: p.lng, altitude: 300 };
        map3d.range = p.range;
        map3d.tilt = p.tilt;
        map3d.heading = p.heading;
        // ★ UIイベント接続（←これが抜けていた）
        $("btnGenerate").onclick = generateFromText;
        $("btnFly").onclick = () => flyToInputPlace();
        $("btnUndo").onclick = () => undoLast();
        $("btnClear").onclick = clearAll;
        $("btnExport").onclick = exportLast;
        $("btnRotate").onclick = () => rotateCameraOnce();
        // $("btnApplyJson").onclick = () => applyJsonSpec();
        $("btnIndividual").onclick = () => exportIndividual();
        // ★ここで archetype 描画
        // const castle = TEMPLATES.find(t => t.id === "castle");
        // if (castle) {
          // renderArchetype(
            // { lat: p.lat, lng: p.lng },
            // castle
          // );
        // }

        setStatus("Ready");
      } catch (e) {
        console.error(e);
        setStatus("初期化エラー: " + e.message);
      }
    });

    let lastSpec = null;
    let lastArchetype = null;

    async function generateFromText() {
      let place = null;          // ★追加（tryの外）
      if (!map3d || !Polygon3DElement) {
        setStatus("まだ初期化中です（API読み込み待ち）");
        return;
      }

      const text = $("prompt").value.trim();
      if (!text) {
        setStatus("テキストを入力してください");
        return;
      }
      currentGroup = []; // ★この生成のグループ開始
      try {
        // =========================
        // 1) 場所解決（B-2a）
        // =========================
        lastRequest = { polygons: [], meta: { prompt: text } };
        setCamera(place);
        setStatus("場所を解決中…");
        place = await resolvePlaceAgent(text); // ★const じゃなく place に代入
        // ★ テンプレ検出
        const qForTpl = removePlaceWords(text);
        const archetype = detectArchetypeFromText(qForTpl);
        lastArchetype = archetype;
        showTemplateInfo(archetype);
        // ★テンプレが見つかったら：AI spec生成(interpret-polygon)は呼ばずにテンプレ描画へ

        if (archetype) {
          setStatus(`テンプレ使用: ${archetype.label}（${archetype.id}）`);

          // ★必ずカメラ移動
          setCamera({
            center: { lat: place.lat, lng: place.lng, altitude: 300 },
            range: place.range ?? 1500,
            tilt: place.tilt ?? 65,
            heading: place.heading ?? 30,
          });

          const center = { lat: place.lat, lng: place.lng };

          // ★テンプレ色を強制青（要件に合わせる）
          const tpl = forceTemplateBlue(archetype);

          renderArchetype(center, tpl);

          // ★この生成をUndo対象に積む
          if (currentGroup.length) renderedGroups.push(currentGroup);

          lastSpec = {
            type: "archetype",
            place,
            archetypeId: archetype.id,
            archetypeLabel: archetype.label
          };

          updateRequestPlaceholder();
          setStatus(`生成完了（テンプレ: ${archetype.label} / ${currentGroup.length}ポリゴン）`);
          return;
        }

        if (!place) {
          setStatus("場所を解決できませんでした");
          return;
        }

        // カメラ移動
        map3d.center = { lat: place.lat, lng: place.lng, altitude: 300 };
        map3d.range = place.range ?? 1500;
        map3d.tilt = place.tilt ?? 65;
        map3d.heading = place.heading ?? 30;

        // =========================
        // 2) ポリゴン仕様をAIで生成（B-2c）
        // =========================
        setStatus("AIがポリゴン仕様を生成中…");
        const r = await fetch("http://localhost:8080/interpret-polygon", {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify({ text })
        });
        if (!r.ok) throw new Error("interpret-polygon failed");
        const spec = await r.json();

        // =========================
        // 3) 図形生成
        // =========================
        const center = { lat: place.lat, lng: place.lng };

        // ★★★★★★★★★★★★★★★★★★★★★★★★★
        // ★ A：テンプレが見つかった場合
        // ★★★★★★★★★★★★★★★★★★★★★★★★★
        if (archetype) {
          setStatus(`テンプレ使用: ${archetype.label}（${archetype.id}）`);

          // ★必ずカメラ移動
          setCamera({
            center: { lat: place.lat, lng: place.lng, altitude: 300 },
            range: place.range ?? 1500,
            tilt: place.tilt ?? 65,
            heading: place.heading ?? 30,
          });

          const center = { lat: place.lat, lng: place.lng };

          // ★テンプレ色を強制青（要件に合わせる）
          const tpl = forceTemplateBlue(archetype);

          renderArchetype(center, tpl);

          // ★この生成をUndo対象に積む
          if (currentGroup.length) renderedGroups.push(currentGroup);

          lastSpec = {
            type: "archetype",
            place,
            archetypeId: archetype.id,
            archetypeLabel: archetype.label
          };

          updateRequestPlaceholder();
          setStatus(`生成完了（テンプレ: ${archetype.label} / ${currentGroup.length}ポリゴン）`);
          return;
        }

        // ★★★★★★★★★★★★★★★★★★★★★★★★★
        // ★ B：テンプレが無い場合（今まで通り）
        // ★★★★★★★★★★★★★★★★★★★★★★★★★

        // ↓↓↓ ここから下は「今のコードを一切変えずに」続ける ↓↓↓
        // zones が来たらそれを優先。無ければ単体描画にフォールバック。
        const baseMeters = pickMeters(spec, text);
        const grid = spec.grid && Number.isFinite(spec.grid.rows) && Number.isFinite(spec.grid.cols)
          ? { rows: Math.max(1, Math.min(10, spec.grid.rows)), cols: Math.max(1, Math.min(10, spec.grid.cols)) }
          : null;

        const zones = Array.isArray(spec.zones) ? spec.zones : null;

        // セル間隔（中心をずらす距離）：ざっくり baseMeters*1.2
        const step = Math.max(80, Math.round(baseMeters * 1.2));

        let cameraUpdated = false;

        function buildPolyAt(center2, zSpec) {
          const meters = pickMeters(zSpec, text) ?? baseMeters;

          let p2;
          if (zSpec.shape === "ngon") p2 = makeNgon(center2, meters, zSpec.sides ?? spec.sides ?? 6);
          else if (zSpec.shape === "circle") p2 = makeCircle(center2, meters);
          else if (zSpec.shape === "triangle") p2 = makeTriangle(center2, meters);
          else p2 = makeRect(center2, meters);

          const height = Number.isFinite(zSpec.height) ? zSpec.height : (spec.height ?? 50);
          const opacity = Number.isFinite(zSpec.opacity) ? zSpec.opacity : (spec.opacity ?? 0.4);
          const colorHex = zSpec.color ?? spec.color ?? "#ff0000";

          const p3 = p2.map(pt => ({ ...pt, altitude: height }));

          const poly = new Polygon3DElement({
            path: p3,
            fillColor: hexToRgba(colorHex, opacity),
            strokeColor: colorHex,
            strokeWidth: 3,
            drawsOccludedSegments: true,
            geodesic: true,
            altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
            extruded: true,
          });

          map3d.append(poly);
          currentGroup.push(poly);
          // ★ 1ポリゴン情報を「最終リクエスト内容」に記録
          pushPolygonRecord({
            kind: "ai",
            shape: zSpec.shape ?? spec.shape ?? "rect",
            sides: zSpec.sides ?? spec.sides ?? null,

            // 再現に必要な中心・大きさ
            center: { lat: center2.lat, lng: center2.lng },
            meters: (Number.isFinite(zSpec.meters) && zSpec.meters > 0) ? zSpec.meters : meters,
            radius: (Number.isFinite(zSpec.radius) && zSpec.radius > 0) ? zSpec.radius : null,

            height,
            color: colorHex,
            opacity,

            // 追加であとから使いたくなるもの（任意）
            extruded: true,
            altitudeMode: "RELATIVE_TO_GROUND"
          });
        }

        // 1) zones があれば zones を描画
        if (zones && zones.length) {
          for (const z of zones) {
            const row = Number.isFinite(z.row) ? z.row : 0;
            const col = Number.isFinite(z.col) ? z.col : 0;
            const rows = grid?.rows ?? 1;
            const cols = grid?.cols ?? 1;
            const dx = (col - (cols - 1) / 2) * step;
            const dy = (row - (rows - 1) / 2) * step;
            const c2 = offsetCenter(center, dx, dy);
            // zonesが同色でも“段階”が見えるように補助（左上=危険 → 右下=安全）
            const idx = row * cols + col;
            const total = rows * cols;
            const t = total <= 1 ? 0 : idx / (total - 1);
            const autoColor = (t < 0.34) ? "#ff0000" : (t < 0.67) ? "#ffaa00" : "#00aa55";
            const autoOpacity = (t < 0.34) ? 0.60 : (t < 0.67) ? 0.48 : 0.36;
            const autoHeight = (t < 0.34) ? (spec.height ?? 60) + 40 : (t < 0.67) ? (spec.height ?? 60) + 15 : (spec.height ?? 60);
            buildPolyAt(c2, {
                ...spec,
                ...z,
                color: z.color ?? autoColor,
                opacity: Number.isFinite(z.opacity) ? z.opacity : autoOpacity,
                height: Number.isFinite(z.height) ? z.height : autoHeight,
              });
          }
        } else if (grid) {
          // 2) zonesが無いが grid があれば、セルを自動生成（簡易：左上→右下で危険→注意→安全の濃淡）
          const total = grid.rows * grid.cols;
          let idx = 0;
          for (let r = 0; r < grid.rows; r++) {
            for (let c = 0; c < grid.cols; c++) {
              const dx = (c - (grid.cols - 1) / 2) * step;
              const dy = (r - (grid.rows - 1) / 2) * step;
              const c2 = offsetCenter(center, dx, dy);

              const t = total <= 1 ? 0 : idx / (total - 1);
              // ざっくり：t小=赤、t中=黄、t大=緑
              const colorHex = (t < 0.34) ? "#ff0000" : (t < 0.67) ? "#ffaa00" : "#00aa55";
              const opacity = (t < 0.34) ? 0.55 : (t < 0.67) ? 0.45 : 0.35;

              buildPolyAt(c2, { ...spec, color: colorHex, opacity });
              idx++;
            }
          }
        } else {
          // 3) 単体描画（従来通り）
          buildPolyAt(center, spec);
        }

        // =========================
        // 4) JSON表示（AI出力そのもの）
        // =========================
        $("json").value = JSON.stringify(
          { prompt: text, place, spec },
          null,
          2
        );

        setStatus("生成完了（AI設計）");
      } catch (e) {
        console.error(e);
        setStatus("生成エラー: " + (e?.message ?? e));
      } finally {
      // ★最後にカメラを確実に合わせる
      if (place) refocusCamera(place);

      // ★Undo対象に積む（テンプレ/AI/個別出力で共通）
      if (currentGroup && currentGroup.length) {
        renderedGroups.push(currentGroup);
      }
      updateRequestPlaceholder(lastSpec);
    }
    }

    // ★ カメラを必ず最終位置に戻す（保険）
    function refocusCamera(place) {
      requestAnimationFrame(() => {
        setTimeout(() => {
          map3d.center = { lat: place.lat, lng: place.lng, altitude: 300 };
          map3d.range = place.range ?? 1500;
          map3d.tilt = place.tilt ?? 65;
          map3d.heading = place.heading ?? 30;
        }, 0);
      });
    }

    async function resolvePlaceAgent(placeText) {
      // まず辞書（東京駅/渋谷など）で即解決
      const known = detectPlace(placeText);
      if (known) return known;

      // 辞書に無ければ server.js に問い合わせ（Gemini）
      setStatus("AIが場所を解決中…");
      const r = await fetch("http://localhost:8080/resolve-place", {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify({ place: placeText }),
      });

      if (!r.ok) {
        const t = await r.text();
        throw new Error("resolve-place failed: " + t);
      }

      const { lat, lng } = await r.json();

      // 視点は固定値でOK（まずは安定優先）
      return { name: placeText, lat, lng, heading: 30, tilt: 65, range: 1500 };
    }

    function renderArchetype(center, archetype) {
      if (!archetype || !Array.isArray(archetype.parts)) return;

      for (const part of archetype.parts) {
        const c2 = offsetCenter(center, part.offset?.x ?? 0, part.offset?.y ?? 0);

        const meters = part.meters ?? part.radius ?? 100;
        let path2d;

        if (part.shape === "circle") {
          path2d = makeCircle(c2, meters);
        } else if (part.shape === "triangle") {
          path2d = makeTriangle(c2, meters);
        } else if (part.shape === "ngon") {
          path2d = makeNgon(c2, meters, part.sides ?? 6);
        } else {
          path2d = makeRect(c2, meters);
        }

        const height = part.height ?? 30;
        const opacity = part.opacity ?? 0.6;
        const color = part.color ?? "#0066ff"; // ← 青テンプレ対応

        const path3d = path2d.map(pt => ({ ...pt, altitude: height }));

        const poly = new Polygon3DElement({
          path: path3d,
          fillColor: hexToRgba(color, opacity),
          strokeColor: color,
          strokeWidth: 3,
          altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
          extruded: true,
          geodesic: true,
        });

        map3d.append(poly);
        currentGroup.push(poly);
      }
    }

    function clearAll() {
      // 現在の作成中グループも含めて消す
      const all = [...renderedGroups];
      if (currentGroup && currentGroup.length) all.push(currentGroup);

      for (const group of all) {
        for (const poly of group) poly.remove();
      }

      renderedGroups = [];
      currentGroup = null;
      lastSpec = null;
      lastArchetype = null;
      lastRequest = { polygons: [], meta: {} };

      $("json").value = "";
      $("apiRequest").value = "";
      showTemplateInfo(null);
      setStatus("クリアしました");
    }

    function exportLast() {
      if (!lastSpec) {
        setStatus("まだ生成されていません");
        return;
      }
      $("json").value = JSON.stringify(lastSpec, null, 2);
      setStatus("JSONを出力しました");
    }

    function normalizeJP(s) {
      return String(s ?? "")
        .toLowerCase()
        .normalize("NFKC") // 全角→半角など
        .replace(/\s+/g, " ")
        .trim();
    }

    function removePlaceWords(text) {
      let s = normalizeJP(text);
      for (const p of PLACE_DB) {
        // PLACE_DBのkeyは正規表現なので、代表語だけざっくり削る
        const name = normalizeJP(p.name);
        if (name) s = s.replaceAll(name, " ");
      }
      // 「に」「へ」「で」などノイズも少し落とす
      s = s.replace(/[にへでをはが]/g, " ");
      return s.replace(/\s+/g, " ").trim();
    }

    function detectArchetypeFromText(text) {
      if (!Array.isArray(TEMPLATES) || TEMPLATES.length === 0) return null;

      const q = normalizeJP(text);
      if (!q) return null;

      // ざっくり「この文章はテンプレ狙いっぽい」判定（AIに行かずテンプレを優先したい時に便利）
      const templateHint = /(建て|建設|作る|つくる|施設|建物|ビル|城|空港|工場|病院|学校|寺|神社|塔|タワー|基地|研究|ホテル|マンション)/.test(q);

      let best = null;
      let bestScore = 0;

      for (const tpl of TEMPLATES) {
        const id = normalizeJP(tpl.id);
        const label = normalizeJP(tpl.label);
        const tags = (tpl.tags ?? []).map(normalizeJP);

        let score = 0;

        // 1) label / id への一致は強く評価
        if (label && q.includes(label)) score += 120;
        if (id && q.includes(id)) score += 90;

        // label を分解して部分一致（例: "中規模オフィスビル"→"オフィス","ビル"）
        if (label) {
          const words = label.split(/[^0-9a-z\u3040-\u30ff\u4e00-\u9faf]+/).filter(Boolean);
          for (const w of words) {
            if (w.length >= 2 && q.includes(w)) score += 20;
          }
        }

        // 2) tags の一致（短いタグは弱め、長いタグは強め）
        for (const tag of tags) {
          if (!tag) continue;
          if (q.includes(tag)) {
            score += (tag.length >= 3) ? 35 : 15;
          } else if (tag.length >= 4) {
            // 部分一致（例: "ランドマーク" タグに対して "ランドマーク的" など）
            if (q.includes(tag.slice(0, Math.min(4, tag.length)))) score += 10;
          }
        }

        // 3) 形状やパーツ構成での補助（ちょい加点）
        const parts = Array.isArray(tpl.parts) ? tpl.parts : [];
        if (parts.length >= 4) score += 5;

        // 4) 「テンプレで作りたい」雰囲気があるときは、少し下駄を履かせる
        if (templateHint) score += 5;

        if (score > bestScore) {
          bestScore = score;
          best = tpl;
        }
      }

      // 最低点を超えたら採用（ここを調整するとヒット感が変わる）
      if (bestScore >= 35) return best;
      return null;
    }
    let isRotating = false;

    function rotateCameraOnce() {
      if (!map3d || isRotating) return;

      isRotating = true;
      setStatus("カメラ回転中…");

      const startHeading = map3d.heading ?? 0;
      const duration = 4000; // 4秒で1周
      const startTime = performance.now();

      function step(now) {
        const t = Math.min((now - startTime) / duration, 1);
        const eased = easeInOut(t);

        map3d.heading = startHeading + eased * 360;

        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          map3d.heading = (startHeading + 360) % 360;
          isRotating = false;
          setStatus("Ready");
        }
      }

      requestAnimationFrame(step);
    }

    // なめらかにするイージング
    function easeInOut(t) {
      return t < 0.5
        ? 2 * t * t
        : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function showTemplateInfo(archetype) {
      const el = $("templateInfo");
      if (!archetype) {
        el.textContent = "使用テンプレ：なし（AI生成）";
      } else {
        el.textContent = `使用テンプレ：${archetype.label}（${archetype.id}）`;
      }
    }

    function applyJsonSpec() {
      if (!map3d || !Polygon3DElement) {
        setStatus("マップ未初期化");
        return;
      }

      try {
        const obj = JSON.parse($("json").value);
        const spec = obj.spec ?? obj; // spec単体でもOK

        // 今見ている中心
        const center = {
          lat: map3d.center.lat,
          lng: map3d.center.lng
        };

        // 既存ポリゴンは消さない（←個別調整向け）
        const meters = pickMeters(spec, "");
        let path2d;

        if (spec.shape === "ngon")
          path2d = makeNgon(center, meters, spec.sides ?? 6);
        else if (spec.shape === "circle")
          path2d = makeCircle(center, meters);
        else if (spec.shape === "triangle")
          path2d = makeTriangle(center, meters);
        else
          path2d = makeRect(center, meters);

        const height = spec.height ?? 50;
        const opacity = spec.opacity ?? 0.4;
        const color = spec.color ?? "#ff0000";

        const path3d = path2d.map(pt => ({ ...pt, altitude: height }));

        const poly = new Polygon3DElement({
          path: path3d,
          fillColor: hexToRgba(color, opacity),
          strokeColor: color,
          strokeWidth: 3,
          altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
          extruded: true,
          geodesic: true
        });

        map3d.append(poly);
        currentGroup.push(poly);

        setStatus("JSONから個別ポリゴンを生成しました");
      } catch (e) {
        console.error(e);
        setStatus("JSON解析エラー：" + e.message);
      }
    }

    function undoLast() {
      if (currentGroup && currentGroup.length) {
        // まだ確定してない作成中があれば先に消す（誤操作対策）
        for (const poly of currentGroup) poly.remove();
        currentGroup = null;
        setStatus("作成中のポリゴンをUndoしました");
        return;
      }

      if (!renderedGroups.length) {
        setStatus("Undoできる生成がありません");
        return;
      }

      const group = renderedGroups.pop();
      for (const poly of group) poly.remove();
      setStatus(`最後の生成（${group.length}ポリゴン）をUndoしました`);
    }

    function exportIndividual() {
      currentGroup = []; // ★個別出力も1グループ扱い
      try {
        const obj = JSON.parse($("apiRequest").value);

        // 1) カメラ遷移（★これが今回の要件）
        if (obj.camera) setCamera(obj.camera);

        // 2) polygons を描画（★手修正が反映される）
        if (!Array.isArray(obj.polygons) || obj.polygons.length === 0) {
          setStatus("polygons が空です（apiRequest を確認）");
          return;
        }

        // 過去を消したくないなら消さない（必要ならここでclearAll()）
        // clearAll();

        for (const p of obj.polygons) {
          const center = p.center;
          if (!center || !Number.isFinite(center.lat) || !Number.isFinite(center.lng)) continue;

          const meters = Number.isFinite(p.meters) && p.meters > 0 ? p.meters : 260;
          const radius = Number.isFinite(p.radius) && p.radius > 0 ? p.radius : null;

          const shape = p.shape ?? "rect";
          const sides = Number.isFinite(p.sides) ? p.sides : 6;

          const height = Number.isFinite(p.height) ? p.height : 50;
          const opacity = Number.isFinite(p.opacity) ? p.opacity : 0.4;
          const colorHex = p.color ?? "#ff0000";

          let path2d;
          if (shape === "circle") path2d = makeCircle(center, radius ?? meters);
          else if (shape === "triangle") path2d = makeTriangle(center, meters);
          else if (shape === "ngon") path2d = makeNgon(center, meters, sides);
          else path2d = makeRect(center, meters);

          const path3d = path2d.map(pt => ({ ...pt, altitude: height }));

          const poly = new Polygon3DElement({
            path: path3d,
            fillColor: hexToRgba(colorHex, opacity),
            strokeColor: colorHex,
            strokeWidth: 3,
            drawsOccludedSegments: true,
            geodesic: true,
            altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
            extruded: true,
          });

          map3d.append(poly);
          currentGroup.push(poly);
        }

        setStatus("個別出力：JSONの内容で再描画しました");
      } catch (e) {
        console.error(e);
        setStatus("個別出力エラー: " + (e?.message ?? e));
      }
      if (currentGroup.length) renderedGroups.push(currentGroup);
      updateRequestPlaceholder();
    }

    function updateRequestPlaceholder() {
      if (!lastRequest) return;

      const payload = {
        camera: {
          center: map3d.center,
          range: map3d.range,
          tilt: map3d.tilt,
          heading: map3d.heading
        },
        polygons: lastRequest.polygons ?? [],
        meta: lastRequest.meta ?? {}
      };

      $("apiRequest").value = JSON.stringify(payload, null, 2);
    }

    function forceTemplateBlue(tpl) {
      return {
        ...tpl,
        parts: tpl.parts.map(p => ({
          ...p,
          color: "#0066ff",
          opacity: p.opacity ?? 0.85
        }))
      };
    }
    function setCamera(placeOrCam) {
      if (!map3d) return;

      // place でも camera でも受けられるように
      const cam = placeOrCam?.center ? placeOrCam : {
        center: placeOrCam?.lat != null ? { lat: placeOrCam.lat, lng: placeOrCam.lng, altitude: 300 } : map3d.center,
        range: placeOrCam?.range ?? 1500,
        tilt: placeOrCam?.tilt ?? 65,
        heading: placeOrCam?.heading ?? 30
      };

      // ★ 反映が遅れることがあるので、2段階で当てる
      map3d.center = cam.center;
      map3d.range = cam.range;
      map3d.tilt = cam.tilt;
      map3d.heading = cam.heading;

      requestAnimationFrame(() => {
        map3d.center = cam.center;
        map3d.range = cam.range;
        map3d.tilt = cam.tilt;
        map3d.heading = cam.heading;
      });
    }

    function pushPolygonRecord(rec) {
      if (!lastRequest) lastRequest = { polygons: [], meta: {} };
      if (!Array.isArray(lastRequest.polygons)) lastRequest.polygons = [];
      lastRequest.polygons.push(rec);
    }

    async function flyToInputPlace() {
      const text = $("prompt").value.trim();
      if (!text) {
        setStatus("場所が入力されていません");
        return;
      }

      try {
        setStatus("Fly中…");

        const place = await resolvePlaceAgent(text);
        if (!place) {
          setStatus("場所を解決できませんでした");
          return;
        }

        await flyCameraTo(place);

        setStatus(`Fly完了：${place.name}`);
      } catch (e) {
        console.error(e);
        setStatus("Flyエラー: " + e.message);
      }
    }

    async function flyCameraTo(place) {
      const s = {
        lat: map3d.center.lat,
        lng: map3d.center.lng,
        range: map3d.range ?? 1500,
        heading: map3d.heading ?? 0,
        tilt: map3d.tilt ?? 65,
      };

      const e = {
        lat: place.lat,
        lng: place.lng,
        range: place.range ?? 1500,
        heading: place.heading ?? 30,
        tilt: place.tilt ?? 65,
      };

      // 距離で演出を変える（遠いほど高く・長く）
      const distKm = approxDistanceKm(s.lat, s.lng, e.lat, e.lng);
      const cruiseRange = clampInt(Math.round(4000 + distKm * 900), 5000, 18000);

      const upDur = clampInt(Math.round(500 + distKm * 30), 600, 1200);
      const moveDur = clampInt(Math.round(900 + distKm * 80), 1200, 4200);
      const downDur = clampInt(Math.round(600 + distKm * 25), 700, 1600);

      // 上昇：tiltを少し寝かせる
      await animateCamera2({
        from: s,
        to: { ...s, range: cruiseRange, tilt: 25 },
        duration: upDur,
      });

      // 移動：headingも少し合わせる
      await animateCamera2({
        from: { ...s, range: cruiseRange, tilt: 25 },
        to: { ...e, range: cruiseRange, tilt: 25, heading: e.heading },
        duration: moveDur,
      });

      // 降下：tilt戻す
      await animateCamera2({
        from: { ...e, range: cruiseRange, tilt: 25 },
        to: e,
        duration: downDur,
      });
    }

    function animateCamera2({ from, to, duration }) {
      const startTime = performance.now();
      return new Promise(resolve => {
        function step(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const e = easeInOutCubic(t);

          map3d.center = {
            lat: lerp(from.lat, to.lat, e),
            lng: lerp(from.lng, to.lng, e),
            altitude: 300,
          };
          map3d.range = lerp(from.range, to.range, e);
          map3d.heading = lerpAngle(from.heading, to.heading, e);
          map3d.tilt = lerp(from.tilt, to.tilt, e);

          if (t < 1) requestAnimationFrame(step);
          else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    function lerpAngle(a, b, t) {
      // 0/360跨ぎを自然に
      let d = ((b - a + 540) % 360) - 180;
      return a + d * t;
    }

    function approxDistanceKm(lat1, lng1, lat2, lng2) {
      // ざっくり地球距離（十分）
      const R = 6371;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a =
        Math.sin(dLat/2)**2 +
        Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

  </script>
</body>
</html>