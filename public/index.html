<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PolyArch</title>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    .app { height: 100%; display: grid; grid-template-columns: 380px 1fr; }
    @media (max-width: 900px) { .app { grid-template-columns: 1fr; grid-template-rows: 360px 1fr; } }
    *, *::before, *::after { box-sizing: border-box; }
    .panel {
      padding: 16px 14px;
      background: linear-gradient(
        180deg,
        #f4f5f7 0%,
        #eceef1 100%
      );
      border-right: 1px solid #d0d4da;
      color: #1f2937; /* ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼æ–‡å­—0131 */
      box-shadow: 4px 0 18px rgba(0,0,0,0.08);
      z-index: 10;
      height: 100%;
      overflow-y: auto;
      overflow-x: hidden; 
    }
    .panel h2 {
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0.02em;
      margin-bottom: 12px;
      color: #111827;
    }

    @media (max-width: 900px) { .panel { border-right: none; border-bottom: 1px solid #ddd; } }

    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; min-width: 0; }
    button {
      padding: 9px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      color: #111827;
      font-weight: 500;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
      transition: all 0.15s ease;
    }
    button:hover {
      background: #f3f4f6;
      transform: translateY(-1px);
    }
    button.primary {
      background: linear-gradient(135deg, #4b5563, #1f2937);
      color: #fff;
      border: none;
    }
    button.primary:hover {
      opacity: 0.9;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    textarea {
      width: 100%;
      max-width: 100%;
      min-height: 20px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      color: #111827;
      font-size: 12px;
      line-height: 0.8;
    }
    textarea:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 2px rgba(99,102,241,0.15);
    }
    textarea.mono {
      background: #0f172a;       /* æ¿ƒã„ãƒã‚¤ãƒ“ãƒ¼ */
      color: #e5e7eb;
      border: none;
      font-size: 12px;
    }
    textarea.mono::placeholder {
      color: #64748b;
    }
    .status {
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 999px;
      background: #e5e7eb;
      color: #374151;
      font-size: 12px;
    }
    #templateInfo {
      margin-top: 6px;
      padding: 6px 10px;
      border-radius: 8px;
      background: #dbeafe;
      color: #1e40af;
      font-size: 12px;
    }
    .app { height: 100vh; } /* 100%ã‚ˆã‚Šå®‰å®š */
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      margin: 4px 0 12px;
    }
    .brandLogo{
      width: 40px;
      height: 40px;
      border-radius: 10px;
      object-fit: cover;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
    }
    .brandTitle{
      font-size: 22px;
      font-weight: 800;
      line-height: 1.2;
      display: flex;         /* æ¨ªä¸¦ã³ã«ã™ã‚‹ */
      align-items: baseline; /* æ–‡å­—ã®åº•è¾ºã‚’æƒãˆã‚‹ */
      gap: 6px;
    }
    .brandSub{
      font-size: 10px;
      color: #6b7280;
      font-weight: 400;
      letter-spacing: 0;
    }
    /* éè¡¨ç¤ºã«ã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ */
    .hidden {
      display: none !important;
    }
    gmp-map-3d { width: 100%; height: 100%; display: block; }
  </style>

  <!-- Maps JS API (v=beta) + maps3d -->
  <!-- â€»è­¦å‘Š(loading=async)ã¯æ€§èƒ½é¢ã®æ¨å¥¨ã€‚å‹•ä½œä¸Šã¯ç„¡è¦–ã—ã¦OKã€‚å¿…è¦ãªã‚‰å¾Œã§asyncãƒ­ãƒ¼ãƒ‰ã«å¤‰ãˆã‚‰ã‚Œã¾ã™ -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDTFkU4wbXOw1dFvz9YER8e10BRC1XIkeE&v=beta&libraries=maps3d"
    defer
  ></script>
</head>

<body>
  <div class="app">
    <aside class="panel">
      <div class="brand">
        <img class="brandLogo" src="./PolyArch_main.png" alt="logo">
        <div class="brandTitle">
          PolyArch<span class="brandSub">v1.0</span>
        </div>
      </div>
      <div class="row">
        <button id="btnGenerate" class="primary">ç”Ÿæˆ</button>
        <button id="btnFly">ç§»å‹•</button>
        <button id="btnUndo">æˆ»ã™</button>
        <button id="btnClear">ã‚¯ãƒªã‚¢</button>
        <button id="btnRotate">å›è»¢</button>
      </div>
      <div class="row">
        <button hidden id="btnModel">ãƒ¢ãƒ‡ãƒ«</button>
        <select id="modelSelect"></select>
        <div class="row" style="align-items:center;">
          <!-- <label class="mono" for="modelSelect" style="min-width:72px;">Model</label>
          <select id="modelSelect" style="flex:1; padding:10px; border-radius:10px; border:1px solid #ccc;">
            <option value="">ï¼ˆmanifestèª­è¾¼ä¸­â€¦ï¼‰</option>
          </select> -->
          <button id="btnPlaceModel">é…ç½®</button>
        </div>

        <!-- <div class="hint" style="margin-top:6px;">
          ãƒ¢ãƒ‡ãƒ«ã‚’é¸æŠâ†’ã€Œé…ç½®ã€ã§ã€prompt ã®å ´æ‰€ï¼ˆãªã‘ã‚Œã°ç¾åœ¨åœ°ï¼‰ã«ç½®ãã¾ã™ã€‚
        </div> -->
      </div>

      <textarea id="prompt" class="mono" placeholder="ä¾‹ï¼šå°å ´å…¬åœ’ æˆ¸å»ºã¦ä½å®…"></textarea>

      <!-- Chat UI -->
      <div style="margin-top:16px;">
        <h3 style="margin:6px 0;">AIãƒãƒ£ãƒƒãƒˆ</h3>

        <div id="chatLog"
            style="height:250px; overflow:auto; border:1px solid #ccc;
                    border-radius:10px; padding:8px; background:#fff;"
            class="mono"></div>

        <div class="row" style="margin-top:6px;">
          <input id="chatInput"
                placeholder="ä¾‹ï¼šå¤§é˜ªåŸã¸ç§»å‹•ã—ã¦"
                style="flex:1; padding:8px; border-radius:8px; border:1px solid #ccc;">
          <button id="btnChat">é€ä¿¡</button>
        </div>
      </div>
      
      <div class="row">
        <button id="btnToggleDetails">è©³ç´°è¡¨ç¤º â–¼</button>
      </div>

      <div id="detailsArea" class="hidden">
      <div class="row" style="margin-top:8px;">
        <button id="btnExport">JSONå‡ºåŠ›</button>
        <button id="btnIndividual">å€‹åˆ¥å‡ºåŠ›</button>
      </div>

      <textarea id="json" class="mono" placeholder="ç”Ÿæˆã®ãƒ­ã‚°(JSON)"></textarea>

      <textarea id="apiRequest" class="mono" placeholder="Maps(æç”»)ã«æœ€çµ‚çš„ã«æ¸¡ã—ãŸå†…å®¹ï¼ˆç·¨é›†ã—ã¦å€‹åˆ¥å‡ºåŠ›ã«ä½¿ãˆã¾ã™ï¼‰"></textarea>

      <div class="mono" id="templateInfo">ä½¿ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ï¼šãªã—</div>
      <div class="status mono" id="status">Ready</div>

      <div class="hint" style="margin-top:10px;">
        å€‹åˆ¥å‡ºåŠ›ï¼šå³ã®apiRequestã‚’æ‰‹ä¿®æ­£ â†’ã€Œå€‹åˆ¥å‡ºåŠ›ã€â†’ãã®é€šã‚Šã«å†æç”»ï¼ˆUndoå¯¾è±¡=1ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰
      </div>
      <div class="hint">
        ä¾‹ï¼š<br/>
        <!-- ãƒ»ã€Œãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ–ãƒªãƒƒã‚¸ã«èµ¤ã„å±é™ºåŒºåŸŸ é«˜ã•60m åŠé€æ˜ã€<br/> -->
        ãƒ»ã€Œæ±äº¬é§…ã« åŸã€<br/>
        ãƒ»ã€Œæ¸‹è°·ã« ç·‘ã®å†† é€æ˜åº¦0.2 é«˜ã•30ã€<br/>
        ãƒ»ã€Œ35.648393327786444, 139.77089018440887ã€€æˆ¸å»ºã¦ä½å®…ã‚’å»ºã¦ã‚‹ã€<br/><!-- <br/>
        å¯¾å¿œï¼šå ´æ‰€(è¾æ›¸/AI) / ãƒ†ãƒ³ãƒ—ãƒ¬ã‚¿ã‚° / å½¢ / é«˜ã• / é€æ˜åº¦ / è‰²<br/>
        â€»ãƒ†ãƒ³ãƒ—ãƒ¬ãŒãƒ’ãƒƒãƒˆã™ã‚Œã°ãƒ†ãƒ³ãƒ—ãƒ¬å„ªå…ˆã€ãªã‘ã‚Œã°AIè§£é‡ˆï¼ˆlocalhostï¼‰ã¸ã€‚ -->
      </div>
       <div class="hint" style="margin-top:10px;">
        æˆ¸å»ºã¦ä½å®…ï¼ˆè©³ç´°ï¼‰ / ä½å±¤é›†åˆä½å®… / ä¸­è¦æ¨¡ã‚ªãƒ•ã‚£ã‚¹ãƒ“ãƒ« / ã‚¿ãƒ¯ãƒ¼å‹ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ / çš‡å±…ãƒ»å¤§è¦æ¨¡ä½å±¤ / ç©ºæ¸¯ / å·¥å ´ / ç—…é™¢ / è€äººãƒ›ãƒ¼ãƒ  / åŸ / å®Ÿé¨“æ–½è¨­ãƒ»åŸºåœ° / ãƒ”ãƒ©ãƒŸãƒƒãƒ‰éºè·¡ç¾¤ / ä¸‡é‡Œã®é•·åŸï¼ˆåŒºé–“ï¼‰ / å¥ˆè‰¯ã®å¤§ä»ãƒ»å¤§ä»æ®¿ / ç‰›ä¹…å¤§ä»ï¼ˆå·¨å¤§ä»åƒï¼‰ / ã‚·ãƒ³ãƒ‡ãƒ¬ãƒ©åŸï¼ˆãƒ•ã‚¡ãƒ³ã‚¿ã‚¸ãƒ¼ï¼‰ / æ—¥æœ¬å¼ã®åŸï¼ˆå¼·åŒ–ï¼‰ / æ¶ç©ºã®æœˆ / å·¨äººåƒ / UFO
      </div>
      </div>        
    </aside>
    <main class="mapWrap">
      <gmp-map-3d id="map3d" mode="hybrid"></gmp-map-3d>
    </main>
  </div>
  <input
    type="file"
    id="modelFileInput"
    accept=".gltf,.glb"
    style="display:none"
  />
  <script>
    // =========================
    // 0) ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ­ãƒ¼ãƒ‰
    // =========================
    let TEMPLATES = null;
    async function loadTemplates() {
      const r = await fetch("./templates.json");
      const j = await r.json();
      TEMPLATES = j.archetypes || [];
    }

    const $ = (id) => document.getElementById(id);

    const ROLE_COLOR = {
      base: "#95A5A6",        // åœŸå°ãƒ»åœ°ç›¤
      wall: "#ECF0F1",        // å£
      roof: "#34495E",        // å±‹æ ¹
      tower: "#3498DB",       // å¡”
      accent: "#E74C3C",      // è£…é£¾
      decoration: "#F1C40F",  // è£…é£¾å“
      energy: "#1ABC9C",      // SFãƒ»é­”æ³•
      body: "#F5CBA7",        // äººãƒ»ç”Ÿç‰©
      eye: "#E74C3C"          // ç›®ãƒ»ã‚³ã‚¢
    };

    function setStatus(s) {
      const el = $("status");
      if (el) el.textContent = s;
      else console.log("[status]", s);
    }

    // ã€ŒMaps(æç”»)ã¸æœ€çµ‚çš„ã«æ¸¡ã—ãŸå†…å®¹ã€ã®ä¿æŒï¼ˆâ€»Maps JS APIãã®ã‚‚ã®ã®HTTPã§ã¯ãªãã€Map3Dã«appendã—ãŸå†…å®¹ã®æœ€çµ‚payloadï¼‰
    let lastRequest = null;

    // =========================
    // 1) ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹è¾æ›¸ï¼ˆå ´æ‰€â†’åº§æ¨™ï¼‰
    // =========================
    const PLACE_DB = [
      { key: /æ±äº¬é§…/, name: "æ±äº¬é§…", lat: 35.681236, lng: 139.767125, heading: 30, tilt: 65, range: 1600 },
      { key: /æ¸‹è°·/, name: "æ¸‹è°·", lat: 35.658034, lng: 139.701636, heading: 20, tilt: 65, range: 1500 },
      { key: /ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ–ãƒªãƒƒã‚¸|è™¹ã®æ©‹/, name: "ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ–ãƒªãƒƒã‚¸", lat: 35.6367, lng: 139.8753, heading: 35, tilt: 65, range: 1500 },
      { key: /æ±äº¬ã‚¿ãƒ¯ãƒ¼/, name: "æ±äº¬ã‚¿ãƒ¯ãƒ¼", lat: 35.658581, lng: 139.745433, heading: 40, tilt: 65, range: 1400 },
      { key: /ãƒ‡ã‚£ã‚ºãƒ‹ãƒ¼|èˆæµœ/, name: "æ±äº¬ãƒ‡ã‚£ã‚ºãƒ‹ãƒ¼ãƒªã‚¾ãƒ¼ãƒˆ", lat: 35.632896, lng: 139.880394, heading: 10, tilt: 65, range: 1700 },
      { key: /æ±äº¬ãƒ‰ãƒ¼ãƒ /, name: "æ±äº¬ãƒ‰ãƒ¼ãƒ ", lat: 35.705639, lng: 139.751891, heading: 20, tilt: 65, range: 1400 },
      { key: /æ½®é¢¨å…¬åœ’/, name: "æ½®é¢¨å…¬åœ’", lat: 35.623218564002364, lng: 139.76899402886113, heading: 20, tilt: 65, range: 1500 },
    ];

    function detectPlace(text) {
      for (const p of PLACE_DB) if (p.key.test(text)) return p;
      return null;
    }

    // =========================
    // 2) å›³å½¢ç”Ÿæˆãƒ˜ãƒ«ãƒ‘ãƒ¼
    // =========================
    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function clampInt(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function hexToRgba(hex, a) {
      const m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(hex);
      if (!m) return `rgba(0,102,255,${a})`;
      const r = parseInt(m[1], 16);
      const g = parseInt(m[2], 16);
      const b = parseInt(m[3], 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    function metersToLat(m){ return m / 111_320; }
    function metersToLng(m, lat){ return m / (111_320 * Math.cos(lat * Math.PI/180)); }

    function offsetCenter(center, dxMeters, dyMeters) {
      return {
        lat: center.lat + metersToLat(dyMeters),
        lng: center.lng + metersToLng(dxMeters, center.lat),
      };
    }

    function makeRect(center, meters=250) {
      const dLat = metersToLat(meters);
      const dLng = metersToLng(meters, center.lat);
      return [
        { lat: center.lat + dLat, lng: center.lng - dLng },
        { lat: center.lat + dLat, lng: center.lng + dLng },
        { lat: center.lat - dLat, lng: center.lng + dLng },
        { lat: center.lat - dLat, lng: center.lng - dLng },
      ];
    }

    function makeTriangle(center, meters=300) {
      const dLat = metersToLat(meters);
      const dLng = metersToLng(meters, center.lat);
      return [
        { lat: center.lat + dLat, lng: center.lng },
        { lat: center.lat - dLat, lng: center.lng - dLng },
        { lat: center.lat - dLat, lng: center.lng + dLng },
      ];
    }

    function makeCircle(center, meters=260, n=18) {
      const pts = [];
      for (let i=0;i<n;i++){
        const t = (Math.PI*2*i)/n;
        const dx = Math.cos(t)*meters;
        const dy = Math.sin(t)*meters;
        const lat = center.lat + metersToLat(dy);
        const lng = center.lng + metersToLng(dx, center.lat);
        pts.push({ lat, lng });
      }
      return pts;
    }

    function makeNgon(center, meters = 260, sides = 6) {
      const n = Math.max(3, Math.min(48, Math.round(sides)));
      const pts = [];
      for (let i = 0; i < n; i++) {
        const t = (Math.PI * 2 * i) / n;
        const dx = Math.cos(t) * meters;
        const dy = Math.sin(t) * meters;
        const lat = center.lat + metersToLat(dy);
        const lng = center.lng + metersToLng(dx, center.lat);
        pts.push({ lat, lng });
      }
      return pts;
    }

    function parseMetersFromText(text) {
      const km = text.match(/([0-9]+(?:\.[0-9]+)?)\s*km/i);
      if (km) return Math.round(parseFloat(km[1]) * 1000);

      const m = text.match(/([0-9]+(?:\.[0-9]+)?)\s*m/i);
      if (m) return Math.round(parseFloat(m[1]));

      const han = text.match(/åŠå¾„\s*([0-9]+(?:\.[0-9]+)?)\s*m?/);
      if (han) return Math.round(parseFloat(han[1]));

      return null;
    }

    function pickMeters(spec, originalText) {
      if (Number.isFinite(spec?.radius) && spec.radius > 0) return Math.max(30, spec.radius);
      if (Number.isFinite(spec?.meters) && spec.meters > 0) return Math.max(30, spec.meters);

      const t = parseMetersFromText(originalText);
      if (Number.isFinite(t)) return Math.max(30, t);

      const size = String(spec?.size ?? "medium").toLowerCase();
      if (size === "small") return 160;
      if (size === "large") return 450;
      return 260;
    }

    // =========================
    // 3) maps3d
    // =========================

    // ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†ï¼ˆUndo/ã‚¯ãƒªã‚¢ã®æ ¸ï¼‰
    let renderedGroups = [];
    // let currentGroup = null; // ä»Šå›ç”Ÿæˆåˆ†

    // æœ€å¾Œã®ç”Ÿæˆãƒ­ã‚°ï¼ˆJSONå‡ºåŠ›ç”¨ï¼‰
    let lastSpec = null;
    let lastArchetype = null;

    // â˜…ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§æŒã¤ï¼ˆé‡è¦ï¼‰
    let map3d, Polygon3DElement, AltitudeMode, Model3DElement;

    window.addEventListener("load", async () => {
      try {
        await loadTemplates();

        // â˜…1) manifestèª­ã¿è¾¼ã¿ â†’ selectåæ˜ 
        await loadModelManifest();
        populateModelSelect();

        // â˜…2) maps3d èª­ã¿è¾¼ã¿ï¼ˆModel3DElementã‚‚ã“ã“ã§ã‚»ãƒƒãƒˆã•ã‚Œã‚‹ï¼‰
        ({ Polygon3DElement, AltitudeMode, Model3DElement } =
          await google.maps.importLibrary("maps3d"));

        await customElements.whenDefined("gmp-map-3d");
        map3d = $("map3d");    
    
        // åˆæœŸä½ç½®
        const p = PLACE_DB[6];
        setCamera({
          center: { lat: p.lat, lng: p.lng, altitude: 300 },
          range: p.range,
          tilt: p.tilt,
          heading: p.heading,
        });

        // UIã‚¤ãƒ™ãƒ³ãƒˆ
        $("btnGenerate").onclick = generateFromText;
        $("btnFly").onclick = flyToInputPlace;
        $("btnUndo").onclick = undoLast;
        $("btnClear").onclick = clearAll;
        $("btnExport").onclick = exportLast;
        $("btnRotate").onclick = rotateCameraOnce;
        $("btnIndividual").onclick = exportIndividual;
        $("btnModel").onclick = () => {
          $("modelFileInput").click();
        };
        $("btnPlaceModel").onclick = () => {
              const m = getSelectedModel();
              placeModelFromManifest(m);
            };
        // åˆæœŸè¡¨ç¤º
        lastRequest = { polygons: [], meta: {} };
        updateRequestPlaceholder();
        setStatus("Ready");

        $("modelFileInput").addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (!file) return;

          // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€æ™‚URLã«å¤‰æ›
          const url = URL.createObjectURL(file);

          // prompt ã«æ›¸ã‹ã‚ŒãŸå ´æ‰€ã‚’ä½¿ã†ï¼ˆç„¡ã‘ã‚Œã°ç¾åœ¨åœ°ï¼‰
          let place = detectPlace($("prompt").value);
          if (!place) {
            place = {
              lat: map3d.center.lat,
              lng: map3d.center.lng,
              altitude: 0
            };
          }

          // 3Dãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
          const model = new Model3DElement({
            src: url,
            position: {
              lat: place.lat,
              lng: place.lng,
              altitude: 0
            },
            scale: 40,
            orientation: { tilt: -90, heading: 0, roll: 0 },
            altitudeMode: AltitudeMode.RELATIVE_TO_GROUND
          });

          map3d.append(model);

          // Undo / Clear ç”¨ã«ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†
          if (!currentGroup) currentGroup = [];
          currentGroup.push(model);

          setStatus(`ãƒ¢ãƒ‡ãƒ«é…ç½®ï¼š${file.name}`);
        });

        const btn = $("btnPlaceModel");
        console.log("[manifest] btnPlaceModel:", btn);
        if (btn) btn.onclick = placeSelectedModel;

        setStatus("Ready");
        
      } catch (e) {
        console.error(e);
        setStatus("åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: " + e.message);
      }
    });

    let MODEL_LIST = []; // manifestã‹ã‚‰èª­ã‚€

    let MODEL_MANIFEST = null;

    async function loadModelManifest() {
      const url = "./gltf/manifest.json";
      console.log("[manifest] fetching:", url);

      const r = await fetch(url, { cache: "no-store" });
      console.log("[manifest] status:", r.status);

      if (!r.ok) throw new Error(`manifest load failed: ${r.status}`);

      const j = await r.json();
      console.log("[manifest] json keys:", Object.keys(j));

      MODEL_MANIFEST = j;

      // â˜… å½¢ãƒã‚§ãƒƒã‚¯ï¼ˆmodelsãŒç„¡ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚æ‹¾ã†ï¼‰
      const models = Array.isArray(j.models) ? j.models : Array.isArray(j.items) ? j.items : [];
      console.log("[manifest] models length:", models.length);

      return MODEL_MANIFEST;
    }

    function populateModelSelect() {
      const sel = $("modelSelect");
      console.log("[manifest] populateModelSelect sel:", sel);

      if (!sel) {
        console.warn("[manifest] #modelSelect not found (id mismatch or not in DOM yet)");
        return;
      }

      // manifestå´ã®ã‚­ãƒ¼åã‚†ã‚Œå¯¾å¿œ
      const models = Array.isArray(MODEL_MANIFEST?.models)
        ? MODEL_MANIFEST.models
        : Array.isArray(MODEL_MANIFEST?.items)
          ? MODEL_MANIFEST.items
          : [];

      sel.innerHTML = "";

      if (!models.length) {
        sel.innerHTML = `<option value="">ï¼ˆãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ / manifestå½¢å¼ã‚’ç¢ºèªï¼‰</option>`;
        return;
      }

      sel.appendChild(new Option("ãƒ¢ãƒ‡ãƒ«ã‚’é¸æŠâ€¦", ""));

      for (const m of models) {
        // å¿…é ˆï¼šid / file
        const id = m.id ?? m.name ?? "";
        const file = m.file ?? m.path ?? "";
        const label = m.label ?? id;

        if (!id || !file) continue;

        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = label;
        opt.dataset.file = file;              // â˜…ã‚ã¨ã§ä½¿ã†
        opt.dataset.scale = m.scale ?? "";    // â˜…ã‚ã¨ã§ä½¿ã†
        sel.appendChild(opt);
      }

      console.log("[manifest] select options:", sel.options.length);
    }

    function getSelectedModel() {
      const id = $("modelSelect")?.value;
      if (!id) return null;
      const models = MODEL_MANIFEST?.models ?? [];
      return models.find(x => x.id === id) ?? null;
    }

    // =========================
    // 4) ãƒ†ãƒ³ãƒ—ãƒ¬æ¤œå‡ºï¼ˆåœ°åãƒã‚¤ã‚ºé™¤å»ã§å½“ãŸã‚Šã‚„ã™ãï¼‰
    // =========================
    function normalizeJP(s) {
      return String(s ?? "")
        .toLowerCase()
        .normalize("NFKC")
        .replace(/\s+/g, " ")
        .trim();
    }

    function removePlaceWords(text) {
      let s = normalizeJP(text);
      for (const p of PLACE_DB) {
        const name = normalizeJP(p.name);
        if (name) s = s.replaceAll(name, " ");
      }
      // åŠ©è©ãªã©è»½ãè½ã¨ã™
      s = s.replace(/[ã«ã¸ã§ã‚’ã¯ãŒ]/g, " ");
      return s.replace(/\s+/g, " ").trim();
    }

    function detectArchetypeFromText(text) {
      if (!Array.isArray(TEMPLATES) || TEMPLATES.length === 0) return null;

      const q = normalizeJP(text);
      if (!q) return null;

      const templateHint = /(å»ºã¦|å»ºè¨­|ä½œã‚‹|ã¤ãã‚‹|æ–½è¨­|å»ºç‰©|ãƒ“ãƒ«|åŸ|ç©ºæ¸¯|å·¥å ´|ç—…é™¢|å­¦æ ¡|å¯º|ç¥ç¤¾|å¡”|ã‚¿ãƒ¯ãƒ¼|åŸºåœ°|ç ”ç©¶|ãƒ›ãƒ†ãƒ«|ãƒãƒ³ã‚·ãƒ§ãƒ³|éºè·¡|ç¥æ®¿|å®®æ®¿|UFO|å·¨äºº|æ€ªç£)/.test(q);

      let best = null;
      let bestScore = 0;

      for (const tpl of TEMPLATES) {
        const id = normalizeJP(tpl.id);
        const label = normalizeJP(tpl.label);
        const tags = (tpl.tags ?? []).map(normalizeJP);

        let score = 0;

        if (label && q.includes(label)) score += 120;
        if (id && q.includes(id)) score += 90;

        if (label) {
          const words = label.split(/[^0-9a-z\u3040-\u30ff\u4e00-\u9faf]+/).filter(Boolean);
          for (const w of words) if (w.length >= 2 && q.includes(w)) score += 20;
        }

        for (const tag of tags) {
          if (!tag) continue;
          if (q.includes(tag)) score += (tag.length >= 3) ? 35 : 15;
          else if (tag.length >= 4) {
            if (q.includes(tag.slice(0, Math.min(4, tag.length)))) score += 10;
          }
        }

        const parts = Array.isArray(tpl.parts) ? tpl.parts : [];
        if (parts.length >= 10) score += 12;
        else if (parts.length >= 4) score += 5;

        if (templateHint) score += 5;

        if (score > bestScore) {
          bestScore = score;
          best = tpl;
        }
      }

      return (bestScore >= 35) ? best : null;
    }

    function showTemplateInfo(archetype) {
      const el = $("templateInfo");
      if (!el) return;
      el.textContent = archetype
        ? `ä½¿ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ï¼š${archetype.label}ï¼ˆ${archetype.id}ï¼‰`
        : "ä½¿ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ï¼šãªã—ï¼ˆAIç”Ÿæˆï¼‰";
    }

    // ãƒ†ãƒ³ãƒ—ãƒ¬è‰²ã‚’é’ã«å¼·åˆ¶ï¼ˆè¦ä»¶ï¼‰
    // function forceTemplateBlue(tpl) {
      // return {
        // ...tpl,
        // parts: (tpl.parts ?? []).map(p => ({
          // ...p,
          // color: "#0066ff",
          // opacity: Number.isFinite(p.opacity) ? p.opacity : 0.85,
        // }))
      // };
    // }

    // =========================
    // 5) ã‚«ãƒ¡ãƒ©
    // =========================
    function setCamera(placeOrCam) {
      if (!map3d) return;

      const cam = placeOrCam?.center ? placeOrCam : {
        center: placeOrCam?.lat != null
          ? { lat: placeOrCam.lat, lng: placeOrCam.lng, altitude: 300 }
          : map3d.center,
        range: placeOrCam?.range ?? 1500,
        tilt: placeOrCam?.tilt ?? 65,
        heading: placeOrCam?.heading ?? 30
      };

      map3d.center = cam.center;
      map3d.range = cam.range;
      map3d.tilt = cam.tilt;
      map3d.heading = cam.heading;

      // åæ˜ ä¿é™º
      requestAnimationFrame(() => {
        map3d.center = cam.center;
        map3d.range = cam.range;
        map3d.tilt = cam.tilt;
        map3d.heading = cam.heading;
      });
    }

    function refocusCamera(place) {
      if (!place || !map3d) return;
      requestAnimationFrame(() => {
        setCamera({
          center: { lat: place.lat, lng: place.lng, altitude: 300 },
          range: place.range ?? 1500,
          tilt: place.tilt ?? 65,
          heading: place.heading ?? 30,
        });
      });
    }

    // =========================
    // 6) æœ€çµ‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹ï¼ˆplaceholderï¼‰ç®¡ç†
    // =========================
    function pushPolygonRecord(rec) {
      if (!lastRequest) lastRequest = { polygons: [], meta: {} };
      if (!Array.isArray(lastRequest.polygons)) lastRequest.polygons = [];
      lastRequest.polygons.push(rec);
    }

    function updateRequestPlaceholder() {
      if (!map3d) return;
      if (!lastRequest) lastRequest = { polygons: [], meta: {} };

      const payload = {
        camera: {
          center: map3d.center,
          range: map3d.range,
          tilt: map3d.tilt,
          heading: map3d.heading
        },
        polygons: lastRequest.polygons ?? [],
        meta: lastRequest.meta ?? {}
      };

      const el = $("apiRequest");
      if (el) el.value = JSON.stringify(payload, null, 2);
    }

    // =========================
    // 7) æç”»ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ï¼‰
    // =========================
    function renderArchetype(center, archetype) {
      if (!archetype || !Array.isArray(archetype.parts)) return;
      if (!currentGroup) currentGroup = []; // â˜…ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ç©ã‚€

      for (const part of archetype.parts) {
        const c2 = offsetCenter(center, part.offset?.x ?? 0, part.offset?.y ?? 0);

        const meters = part.meters ?? part.radius ?? 100;

        let path2d;
        if (part.shape === "circle") path2d = makeCircle(c2, meters);
        else if (part.shape === "triangle") path2d = makeTriangle(c2, meters);
        else if (part.shape === "ngon") path2d = makeNgon(c2, meters, part.sides ?? 6);
        else path2d = makeRect(c2, meters);

        const height = part.height ?? 30;
        const color = resolvePartColor(part, archetype);
        const opacity = part.opacity ?? 0.7; // â† åŠé€æ˜ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«
        const path3d = path2d.map(pt => ({ ...pt, altitude: height }));

        const poly = new Polygon3DElement({
          path: path3d,
          fillColor: hexToRgba(color, opacity),
          strokeColor: color,
          strokeWidth: 3,
          altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
          extruded: true,
          geodesic: true
        });

        map3d.append(poly);
        currentGroup.push(poly);

        // â˜…ãƒ†ãƒ³ãƒ—ãƒ¬ã‚‚ã€Œå€‹åˆ¥å‡ºåŠ›/æ‰‹ä¿®æ­£ã€ã§ãã‚‹ã‚ˆã†ã«è¨˜éŒ²
        pushPolygonRecord({
          kind: "template",
          shape: part.shape ?? "rect",
          sides: part.sides ?? null,
          center: { lat: c2.lat, lng: c2.lng },
          meters,
          radius: Number.isFinite(part.radius) ? part.radius : null,
          height,
          color,
          opacity,
          extruded: true,
          altitudeMode: "RELATIVE_TO_GROUND",
          role: part.role ?? null
        });
      }
    }

    // =========================
    // 8) ç”Ÿæˆï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬å„ªå…ˆ â†’ ãªã‘ã‚Œã°AIï¼‰
    // =========================
    async function generateFromText() {
      let place = null;

      if (!map3d || !Polygon3DElement) {
        setStatus("ã¾ã åˆæœŸåŒ–ä¸­ã§ã™ï¼ˆAPIèª­ã¿è¾¼ã¿å¾…ã¡ï¼‰");
        return;
      }

      const text = $("prompt").value.trim();
      if (!text) {
        setStatus("ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }

      // â˜…ã“ã®ç”Ÿæˆã®ã‚°ãƒ«ãƒ¼ãƒ—é–‹å§‹
      currentGroup = [];

      // â˜…ã“ã®ç”Ÿæˆã®placeholderã‚’åˆæœŸåŒ–
      lastRequest = { polygons: [], meta: { prompt: text, mode: null, ts: new Date().toISOString() } };

      try {
        setStatus("å ´æ‰€ã‚’è§£æ±ºä¸­â€¦");
        place = await resolvePlaceAgent(text);
        if (!place) {
          setStatus("å ´æ‰€ã‚’è§£æ±ºã§ãã¾ã›ã‚“ã§ã—ãŸ");
          return;
        }

        // â˜…ã‚«ãƒ¡ãƒ©ç§»å‹•ï¼ˆç”Ÿæˆå‰ã«ç¢ºå®Ÿã«ï¼‰
        setCamera({
          center: { lat: place.lat, lng: place.lng, altitude: 300 },
          range: place.range ?? 1500,
          tilt: place.tilt ?? 65,
          heading: place.heading ?? 30,
        });

        // â˜…ãƒ†ãƒ³ãƒ—ãƒ¬æ¤œå‡ºï¼ˆåœ°åãƒã‚¤ã‚ºé™¤å»ã—ã¦ã‹ã‚‰ï¼‰
        const qForTpl = removePlaceWords(text);
        const archetype = detectArchetypeFromText(qForTpl);
        lastArchetype = archetype;
        showTemplateInfo(archetype);

        // ---- A) ãƒ†ãƒ³ãƒ—ãƒ¬ãŒå½“ãŸã£ãŸã‚‰ãƒ†ãƒ³ãƒ—ãƒ¬æç”»
        if (archetype) {
          lastRequest.meta.mode = "template";
          lastRequest.meta.archetypeId = archetype.id;
          lastRequest.meta.archetypeLabel = archetype.label;

          const center = { lat: place.lat, lng: place.lng };
          // const tpl = forceTemplateBlue(archetype); //
          renderArchetype(center, archetype);

          // ãƒ­ã‚°
          lastSpec = {
            type: "archetype",
            place,
            archetypeId: archetype.id,
            archetypeLabel: archetype.label,
            polygonsCount: currentGroup.length
          };
          $("json").value = JSON.stringify(lastSpec, null, 2);

          updateRequestPlaceholder();             // â˜…ãƒ†ãƒ³ãƒ—ãƒ¬ã§ã‚‚apiRequestã«åæ˜ 
          setStatus(`ç”Ÿæˆå®Œäº†ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬: ${archetype.label} / ${currentGroup.length}ãƒãƒªã‚´ãƒ³ï¼‰`);
          return;
        }

        // ---- B) ãƒ†ãƒ³ãƒ—ãƒ¬ãŒç„¡ã‘ã‚Œã°AIï¼ˆlocalhostï¼‰
        lastRequest.meta.mode = "ai";
        setStatus("AIãŒãƒãƒªã‚´ãƒ³ä»•æ§˜ã‚’ç”Ÿæˆä¸­â€¦");
        const r = await fetch("/interpret-polygon", {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify({ text })
        });
        if (!r.ok) throw new Error("interpret-polygon failed");
        const spec = await r.json();

        const center = { lat: place.lat, lng: place.lng };

        const baseMeters = pickMeters(spec, text);
        const grid = spec.grid && Number.isFinite(spec.grid.rows) && Number.isFinite(spec.grid.cols)
          ? { rows: Math.max(1, Math.min(10, spec.grid.rows)), cols: Math.max(1, Math.min(10, spec.grid.cols)) }
          : null;

        const zones = Array.isArray(spec.zones) ? spec.zones : null;
        const step = Math.max(80, Math.round(baseMeters * 1.2));

        function buildPolyAt(center2, zSpec) {
          const meters = pickMeters(zSpec, text) ?? baseMeters;

          let path2d;
          if (zSpec.shape === "ngon") path2d = makeNgon(center2, meters, zSpec.sides ?? spec.sides ?? 6);
          else if (zSpec.shape === "circle") path2d = makeCircle(center2, meters);
          else if (zSpec.shape === "triangle") path2d = makeTriangle(center2, meters);
          else path2d = makeRect(center2, meters);

          const height = Number.isFinite(zSpec.height) ? zSpec.height : (spec.height ?? 50);
          const opacity = Number.isFinite(zSpec.opacity) ? zSpec.opacity : (spec.opacity ?? 0.4);
          const colorHex = zSpec.color ?? spec.color ?? "#ff0000";

          const path3d = path2d.map(pt => ({ ...pt, altitude: height }));

          const poly = new Polygon3DElement({
            path: path3d,
            fillColor: hexToRgba(colorHex, opacity),
            strokeColor: colorHex,
            strokeWidth: 3,
            drawsOccludedSegments: true,
            geodesic: true,
            altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
            extruded: true,
          });

          map3d.append(poly);
          currentGroup.push(poly);

          pushPolygonRecord({
            kind: "ai",
            shape: zSpec.shape ?? spec.shape ?? "rect",
            sides: zSpec.sides ?? spec.sides ?? null,
            center: { lat: center2.lat, lng: center2.lng },
            meters,
            radius: (Number.isFinite(zSpec.radius) && zSpec.radius > 0) ? zSpec.radius : null,
            height,
            color: colorHex,
            opacity,
            extruded: true,
            altitudeMode: "RELATIVE_TO_GROUND"
          });
        }

        if (zones && zones.length) {
          for (const z of zones) {
            const row = Number.isFinite(z.row) ? z.row : 0;
            const col = Number.isFinite(z.col) ? z.col : 0;
            const rows = grid?.rows ?? 1;
            const cols = grid?.cols ?? 1;
            const dx = (col - (cols - 1) / 2) * step;
            const dy = (row - (rows - 1) / 2) * step;
            const c2 = offsetCenter(center, dx, dy);
            buildPolyAt(c2, { ...spec, ...z });
          }
        } else if (grid) {
          for (let r = 0; r < grid.rows; r++) {
            for (let c = 0; c < grid.cols; c++) {
              const dx = (c - (grid.cols - 1) / 2) * step;
              const dy = (r - (grid.rows - 1) / 2) * step;
              const c2 = offsetCenter(center, dx, dy);
              buildPolyAt(c2, spec);
            }
          }
        } else {
          buildPolyAt(center, spec);
        }

        lastSpec = { prompt: text, place, spec, polygonsCount: currentGroup.length };
        $("json").value = JSON.stringify(lastSpec, null, 2);

        setStatus(`ç”Ÿæˆå®Œäº†ï¼ˆAI / ${currentGroup.length}ãƒãƒªã‚´ãƒ³ï¼‰`);
      } catch (e) {
        console.error(e);
        setStatus("ç”Ÿæˆã‚¨ãƒ©ãƒ¼: " + (e?.message ?? e));
      } finally {
        if (place) refocusCamera(place);

        // â˜…Undoå¯¾è±¡ã¸ç©ã‚€ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—ï¼‰
        if (currentGroup && currentGroup.length) renderedGroups.push(currentGroup);

        updateRequestPlaceholder();

        // ä½œæˆä¸­ã¯è§£æ”¾ï¼ˆèª¤æ“ä½œé˜²æ­¢ï¼‰
        currentGroup = null;
      }
    }

    // =========================
    // 9) å€‹åˆ¥å‡ºåŠ›ï¼ˆapiRequestã®JSONã‚’ãã®ã¾ã¾æç”»ï¼‰
    // =========================
    function exportIndividual() {
      if (!map3d || !Polygon3DElement) {
        setStatus("ãƒãƒƒãƒ—æœªåˆæœŸåŒ–");
        return;
      }

      // â˜…å€‹åˆ¥å‡ºåŠ›ã‚‚1ã‚°ãƒ«ãƒ¼ãƒ—æ‰±ã„
      currentGroup = [];
      try {
        const obj = JSON.parse($("apiRequest").value);

        // 1) ã‚«ãƒ¡ãƒ©é·ç§»
        if (obj.camera) setCamera(obj.camera);

        // 2) polygons ã‚’æç”»
        if (!Array.isArray(obj.polygons) || obj.polygons.length === 0) {
          setStatus("polygons ãŒç©ºã§ã™ï¼ˆapiRequest ã‚’ç¢ºèªï¼‰");
          return;
        }

        // ã“ã®å€‹åˆ¥å‡ºåŠ›åˆ†ã‚’lastRequestã¨ã—ã¦ä¿å­˜ã—ç›´ã™ï¼ˆç·¨é›†å¾ŒãŒãã®ã¾ã¾æ®‹ã‚‹ï¼‰
        lastRequest = {
          polygons: obj.polygons,
          meta: obj.meta ?? { mode: "individual" }
        };

        for (const p of obj.polygons) {
          const center = p.center;
          if (!center || !Number.isFinite(center.lat) || !Number.isFinite(center.lng)) continue;

          const meters = Number.isFinite(p.meters) && p.meters > 0 ? p.meters : 260;
          const radius = Number.isFinite(p.radius) && p.radius > 0 ? p.radius : null;

          const shape = p.shape ?? "rect";
          const sides = Number.isFinite(p.sides) ? p.sides : 6;

          const height = Number.isFinite(p.height) ? p.height : 50;
          const opacity = Number.isFinite(p.opacity) ? p.opacity : 0.4;
          const colorHex = p.color ?? "#ff0000";

          let path2d;
          if (shape === "circle") path2d = makeCircle(center, radius ?? meters);
          else if (shape === "triangle") path2d = makeTriangle(center, meters);
          else if (shape === "ngon") path2d = makeNgon(center, meters, sides);
          else path2d = makeRect(center, meters);

          const path3d = path2d.map(pt => ({ ...pt, altitude: height }));

          const poly = new Polygon3DElement({
            path: path3d,
            fillColor: hexToRgba(colorHex, opacity),
            strokeColor: colorHex,
            strokeWidth: 3,
            drawsOccludedSegments: true,
            geodesic: true,
            altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
            extruded: true,
          });

          map3d.append(poly);
          currentGroup.push(poly);
        }

        setStatus(`å€‹åˆ¥å‡ºåŠ›ï¼š${currentGroup.length}ãƒãƒªã‚´ãƒ³ã‚’æç”»ã—ã¾ã—ãŸ`);

      } catch (e) {
        console.error(e);
        setStatus("å€‹åˆ¥å‡ºåŠ›ã‚¨ãƒ©ãƒ¼: " + (e?.message ?? e));
      } finally {
        if (currentGroup && currentGroup.length) renderedGroups.push(currentGroup);
        updateRequestPlaceholder();
        currentGroup = null;
      }
    }

    // =========================
    // 10) Undo / Clear / JSONå‡ºåŠ›
    // =========================
    function undoLast() {
      // ãƒãƒªã‚´ãƒ³ã®Undo
      if (renderedGroups.length) {
        const group = renderedGroups.pop();
        for (const poly of group) poly.remove();
        setStatus(`Undoï¼ˆãƒãƒªã‚´ãƒ³ ${group.length}ï¼‰`);
        return;
      }

      // ãƒ¢ãƒ‡ãƒ«ã®Undo
      if (renderedModelGroups.length) {
        const group = renderedModelGroups.pop();
        for (const m of group) m.remove();
        setStatus(`Undoï¼ˆãƒ¢ãƒ‡ãƒ« ${group.length}ï¼‰`);
        return;
      }

      setStatus("Undoã§ãã‚‹ç”ŸæˆãŒã‚ã‚Šã¾ã›ã‚“");
    }

    function clearAll() {
      for (const group of renderedGroups) for (const poly of group) poly.remove();
      renderedGroups = [];

      for (const group of renderedModelGroups) for (const m of group) m.remove();
      renderedModelGroups = [];

      lastSpec = null;
      lastArchetype = null;
      lastRequest = null;

      $("json").value = "";
      $("apiRequest").value = "";

      setStatus("ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ");
    }

    function exportLast() {
      if (!lastSpec) {
        setStatus("ã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“");
        return;
      }
      $("json").value = JSON.stringify(lastSpec, null, 2);
      setStatus("JSONã‚’å‡ºåŠ›ã—ã¾ã—ãŸ");
    }

    // =========================
    // 11) å ´æ‰€è§£æ±ºï¼ˆè¾æ›¸â†’AIï¼‰
    // =========================
    async function resolvePlaceAgent(placeText) {
      const known = detectPlace(placeText);
      if (known) return known;

      // è¾æ›¸ã«ç„¡ã‘ã‚Œã° server.js ã«å•ã„åˆã‚ã›ï¼ˆGeminiç­‰ï¼‰
      setStatus("AIãŒå ´æ‰€ã‚’è§£æ±ºä¸­â€¦");
      const r = await fetch("/resolve-place", {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify({ place: placeText }),
      });

      if (!r.ok) {
        const t = await r.text();
        throw new Error("resolve-place failed: " + t);
      }

      const { lat, lng } = await r.json();
      return { name: placeText, lat, lng, heading: 30, tilt: 65, range: 1500 };
    }

    // =========================
    // 12) Flyï¼ˆGoogle Earthã£ã½ã„æ»‘ã‚‰ã‹ç§»å‹•ï¼‰
    // =========================
    async function flyToInputPlace() {
      const text = $("prompt").value.trim();
      if (!text) {
        setStatus("å ´æ‰€ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“");
        return;
      }

      try {
        setStatus("Flyä¸­â€¦");
        const place = await resolvePlaceAgent(text);
        if (!place) {
          setStatus("å ´æ‰€ã‚’è§£æ±ºã§ãã¾ã›ã‚“ã§ã—ãŸ");
          return;
        }
        await flyCameraTo(place);
        setStatus(`Flyå®Œäº†ï¼š${place.name}`);
      } catch (e) {
        console.error(e);
        setStatus("Flyã‚¨ãƒ©ãƒ¼: " + e.message);
      }
    }

    async function flyCameraTo(place) {
      const s = {
        lat: map3d.center.lat,
        lng: map3d.center.lng,
        range: map3d.range ?? 300,
        heading: map3d.heading ?? 0,
        tilt: map3d.tilt ?? 65,
      };

      const e = {
        lat: place.lat,
        lng: place.lng,
        range: place.range ?? 300,
        heading: place.heading ?? 30,
        tilt: place.tilt ?? 65,
      };

      const distKm = approxDistanceKm(s.lat, s.lng, e.lat, e.lng);
      const cruiseRange = clampInt(Math.round(4000 + distKm * 900), 5000, 18000);

      const upDur = clampInt(Math.round(500 + distKm * 30), 600, 1200);
      const moveDur = clampInt(Math.round(900 + distKm * 80), 1200, 4200);
      const downDur = clampInt(Math.round(600 + distKm * 25), 700, 1600);

      await animateCamera2({
        from: s,
        to: { ...s, range: cruiseRange, tilt: 25 },
        duration: upDur,
      });

      await animateCamera2({
        from: { ...s, range: cruiseRange, tilt: 25 },
        to: { ...e, range: cruiseRange, tilt: 25, heading: e.heading },
        duration: moveDur,
      });

      await animateCamera2({
        from: { ...e, range: cruiseRange, tilt: 25 },
        to: e,
        duration: downDur,
      });
    }

    function animateCamera2({ from, to, duration }) {
      const startTime = performance.now();
      return new Promise(resolve => {
        function step(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const e = easeInOutCubic(t);

          map3d.center = {
            lat: lerp(from.lat, to.lat, e),
            lng: lerp(from.lng, to.lng, e),
            altitude: 300,
          };
          map3d.range = lerp(from.range, to.range, e);
          map3d.heading = lerpAngle(from.heading, to.heading, e);
          map3d.tilt = lerp(from.tilt, to.tilt, e);

          if (t < 1) requestAnimationFrame(step);
          else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    function lerpAngle(a, b, t) {
      let d = ((b - a + 540) % 360) - 180;
      return a + d * t;
    }

    function approxDistanceKm(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a =
        Math.sin(dLat/2)**2 +
        Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    // =========================
    // 13) å›è»¢
    // =========================
    let isRotating = false;

    function rotateCameraOnce() {
      if (!map3d || isRotating) return;

      isRotating = true;
      setStatus("ã‚«ãƒ¡ãƒ©å›è»¢ä¸­â€¦");

      const startHeading = map3d.heading ?? 0;
      const duration = 4000;
      const startTime = performance.now();

      function step(now) {
        const t = Math.min((now - startTime) / duration, 1);
        const eased = easeInOut(t);

        map3d.heading = startHeading + eased * 360;

        if (t < 1) requestAnimationFrame(step);
        else {
          map3d.heading = (startHeading + 360) % 360;
          isRotating = false;
          setStatus("Ready");
        }
      }

      requestAnimationFrame(step);
    }

    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function resolvePartColor(part, archetype) {
      if (part.color) return part.color;
      if (archetype?.palette && part.role && archetype.palette[part.role]) return archetype.palette[part.role];
      if (part.role && ROLE_COLOR[part.role]) return ROLE_COLOR[part.role];
      return "#6B7280";
    }

    function renderArchetype(center, archetype) {
      if (!archetype || !Array.isArray(archetype.parts)) return;

      const group = []; // ã‚°ãƒ«ãƒ¼ãƒ—Undoç”¨

      for (const part of archetype.parts) {
        const c2 = offsetCenter(center, part.offset?.x ?? 0, part.offset?.y ?? 0);

        const colorHex = resolvePartColor(part, archetype);
        const opacity = Math.min(0.5, Number.isFinite(part.opacity) ? part.opacity : 0.30);

        // â˜…ä¸­ç©ºãƒ¢ãƒ¼ãƒ‰
        if (part.hollow?.topAlt != null && part.hollow?.bottomAlt != null) {
          const meters = part.meters ?? part.radius ?? 120;

          const { top, bottom } = makeHollowRectPrism(
            c2,
            meters,
            part.hollow.topAlt,
            part.hollow.bottomAlt
          );

          const polyEl = makeHollowPolygon3D({
            outerPath: top,
            innerPaths: [bottom],
            fillColor: hexToRgba(colorHex, opacity),
            strokeColor: colorHex
          });

          map3d.append(polyEl);
          group.push(polyEl);
          continue;
        }

        // â˜…é€šå¸¸ï¼ˆPolygon3DElementï¼‰
        const meters = part.meters ?? part.radius ?? 100;
        let path2d;
        if (part.shape === "circle") path2d = makeCircle(c2, meters);
        else if (part.shape === "triangle") path2d = makeTriangle(c2, meters);
        else if (part.shape === "ngon") path2d = makeNgon(c2, meters, part.sides ?? 6);
        else path2d = makeRect(c2, meters);

        const height = part.height ?? 30;
        const path3d = path2d.map(pt => ({ ...pt, altitude: height }));

        const poly = new Polygon3DElement({
          path: path3d,
          fillColor: hexToRgba(colorHex, opacity),
          strokeColor: colorHex,
          strokeWidth: 3,
          altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
          extruded: true,
          geodesic: true,
        });

        map3d.append(poly);
        group.push(poly);
      }

      renderedGroups.push(group);
    }

    $("btnChat").onclick = sendChat;

    async function sendChat() {
      const input = $("chatInput");
      const msg = input.value.trim();
      if (!msg) return;

      appendChat("user", msg);
      input.value = "";

      try {
        // state ã¯ "ã‚ã‚Œã°" æ¸¡ã™ã€‚ãªãã¦ã‚‚ generate/fly ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
        let state = null;
        if ($("apiRequest").value) {
          const full = JSON.parse($("apiRequest").value);
          state = { polygons: full.polygons ?? [] };
        }

        const r = await fetch("/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: msg, state })
        });

        if (!r.ok) throw new Error("chat failed");

        const res = await r.json();

        // â‘  ãƒãƒ£ãƒƒãƒˆè¡¨ç¤ºï¼ˆ1å›ã ã‘ï¼‰
        appendChat("ai", res.reply);

        switch (res.action) {
          case "generate":
            $("prompt").value = res.prompt ?? msg;   // â˜…ã“ã“è¶…é‡è¦
            await generateFromText();
            break;

          case "fly":
            $("prompt").value = res.prompt ?? msg;   // â˜…ã“ã“è¶…é‡è¦
            await flyToInputPlace();
            break;

          case "undo":
            undoLast();
            break;

          case "clear":
            clearAll();
            break;

          case "rotate":
            rotateCameraOnce();
            break;

          case "open-model-picker":
            $("modelFileInput").click();
            break;

          case "modify":
            if (res.state) {
              // apiRequest ã¯ full å½¢å¼ãªã‚‰ polygons ã‚’å·®ã—æ›¿ãˆã‚‹ã€‚ç„¡ã‘ã‚Œã°ãã®ã¾ã¾
              const full = JSON.parse($("apiRequest").value || "{}");
              full.polygons = res.state.polygons ?? full.polygons ?? [];
              $("apiRequest").value = JSON.stringify(full, null, 2);
              exportIndividual();
            }
            break;
        }
      } catch (e) {
        console.error(e);
        appendChat("ai", "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");
      }
    }

    function appendChat(role, text) {
      const log = $("chatLog");
      const div = document.createElement("div");
      div.style.marginBottom = "6px";
      div.textContent = (role === "user" ? "ğŸ‘¤ " : "ğŸ¤– ") + text;
      log.appendChild(div);
      log.scrollTop = log.scrollHeight;
    }

    function pickPartColor(archetype, part) {
      // 1) json/ãƒ†ãƒ³ãƒ—ãƒ¬å´ã§ part.color ãŒã‚ã‚Œã°ãã‚Œã‚’æœ€å„ªå…ˆ
      if (part.color) return part.color;

      // 2) role ã«è‰²ã‚’å‰²ã‚Šå½“ã¦ã¦ã„ã‚‹ãªã‚‰ãã‚Œ
      const role = String(part.role ?? "").toLowerCase();
      if (ROLE_COLOR && ROLE_COLOR[role]) return ROLE_COLOR[role];

      // 3) archetype å´ã§ baseColor ã‚’æŒãŸã›ã¦ã„ã‚‹ãªã‚‰ãã‚Œï¼ˆä»»æ„ï¼‰
      if (archetype?.baseColor) return archetype.baseColor;

      // 4) æœ€å¾Œã®ä¿é™º
      return "#0066ff";
    }

    function makeHollowPolygon3D({ outerPath, innerPaths, fillColor, strokeColor }) {
      const el = document.createElement("gmp-polygon-3d");

      // ã‚ãªãŸã®æŒ‡å®šã©ãŠã‚Š
      el.setAttribute("altitude-mode", "relative-to-ground");
      el.setAttribute("extruded", "true");

      // ãƒ‘ã‚¹ï¼ˆouter=å¤©é¢ã€inner=åº•é¢ï¼‰
      el.outerPath = outerPath;
      el.innerPaths = innerPaths;

      // è¦‹ãŸç›®
      el.fillColor = fillColor;
      el.strokeColor = strokeColor;
      el.strokeWidth = 3;

      return el;
    }

    function makeRect3DWithAltitude(center, meters, altitude) {
      const pts = makeRect(center, meters);
      return [...pts, pts[0]].map(p => ({ lat: p.lat, lng: p.lng, altitude }));
    }

    function makeHollowRectPrism(center, meters, topAlt, bottomAlt) {
      const top = makeRect3DWithAltitude(center, meters, topAlt);
      const bottom = makeRect3DWithAltitude(center, meters, bottomAlt);
      return { top, bottom };
    }

    let renderedModelGroups = [];  // Undo/Clearç”¨ï¼ˆãƒ¢ãƒ‡ãƒ«ã‚‚ã‚°ãƒ«ãƒ¼ãƒ—ã§ç®¡ç†ï¼‰
    let currentGroup = null;       // æ—¢ã«ä½¿ã£ã¦ã‚‹ãªã‚‰ãã®ã¾ã¾

    function getSelectedModel() {
      const id = $("modelSelect")?.value;
      return MODEL_LIST.find(m => m.id === id) ?? null;
    }

    async function placeModelFromUI(modelId = null, promptText = null) {
      if (!map3d) return setStatus("ãƒãƒƒãƒ—æœªåˆæœŸåŒ–");
      if (!Model3DElement) return setStatus("Model3DElement ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆmaps3då´ã®å¯¾å¿œç¢ºèªï¼‰");

      // 1) ç½®ãå…ˆï¼ˆpromptæ¬„ or æŒ‡å®šï¼‰
      const text = (promptText ?? $("prompt").value).trim();
      if (!text) return setStatus("å ´æ‰€ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“");

      // 2) ç½®ããƒ¢ãƒ‡ãƒ«ï¼ˆUI or æŒ‡å®šï¼‰
      const model = modelId
        ? (MODEL_LIST.find(m => m.id === modelId) ?? null)
        : getSelectedModel();

      if (!model) return setStatus("ãƒ¢ãƒ‡ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆmanifestã‚’ç¢ºèªï¼‰");

      setStatus("ãƒ¢ãƒ‡ãƒ«è¨­ç½®ä¸­â€¦");

      // 3) å ´æ‰€è§£æ±º
      const place = await resolvePlaceAgent(text);

      // 4) ã‚«ãƒ¡ãƒ©ç§»å‹•ï¼ˆå…ˆã«å¯„ã‚‹ï¼‰
      await flyCameraTo(place).catch(() => {
        // flyå¤±æ•—ã—ã¦ã‚‚è¨­ç½®ã¯ç¶šã‘ã‚‹
        setCamera(place);
      });

      // 5) ãƒ¢ãƒ‡ãƒ«ç”Ÿæˆï¼ˆcurrentGroup ã«ç©ã‚€ï¼‰
      if (!currentGroup) currentGroup = [];
      const group = []; // ä»Šå›ã®ãƒ¢ãƒ‡ãƒ«ç¾¤ï¼ˆ1å€‹ã§ã‚‚ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦Undoå¯¾å¿œï¼‰

      const altitude = Number.isFinite(model.altitude) ? model.altitude : 0;
      const heading = Number.isFinite(model.heading) ? model.heading : 0;
      const scale = Number.isFinite(model.scale) ? model.scale : 30;

      // â˜… ãƒ¢ãƒ‡ãƒ«ã®ä½ç½®
      const position = { lat: place.lat, lng: place.lng, altitude };

      // â˜… ã“ã“ãŒModel3Dé…ç½®ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åã¯ç’°å¢ƒã§å¾®å¦™ã«é•ã†å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§tryã§ä¿é™ºï¼‰
      let el;
      try {
        el = new Model3DElement({
          position,
          src: model.src,     // "./gltf/xxx.glb"
          scale,
          heading
        });
      } catch (e) {
        console.error(e);
        return setStatus("ãƒ¢ãƒ‡ãƒ«ç”Ÿæˆã«å¤±æ•—ï¼šModel3DElementã®å¼•æ•°ä»•æ§˜ã‚’ç¢ºèªã—ã¦ãã ã•ã„");
      }

      map3d.append(el);
      group.push(el);

      renderedModelGroups.push(group);

      // apiRequest ã«ã‚‚è¨˜éŒ²ï¼ˆæ‰‹ä¿®æ­£ï¼†å†å‡ºåŠ›ã«ä½¿ãˆã‚‹ï¼‰
      if (!lastRequest) lastRequest = { polygons: [], meta: {} };
      lastRequest.models = Array.isArray(lastRequest.models) ? lastRequest.models : [];
      lastRequest.models.push({
        id: model.id,
        label: model.label,
        src: model.src,
        position,
        scale,
        heading
      });

      updateRequestPlaceholder();
      setStatus(`ãƒ¢ãƒ‡ãƒ«è¨­ç½®å®Œäº†ï¼š${model.label ?? model.id}`);
    }

    const toggleBtn = document.getElementById('btnToggleDetails');
    const detailsArea = document.getElementById('detailsArea');

    toggleBtn.addEventListener('click', () => {
      const isHidden = detailsArea.classList.contains('hidden');
      if (isHidden) {
        detailsArea.classList.remove('hidden');
        toggleBtn.textContent = 'è©³ç´°ã‚’é–‰ã˜ã‚‹ â–²';
      } else {
        detailsArea.classList.add('hidden');
        toggleBtn.textContent = 'è©³ç´°è¡¨ç¤º â–¼';
      }
    });

    function getPlaceFromPromptOrCenter() {
      const t = $("prompt")?.value?.trim() ?? "";
      const p = detectPlace(t);
      if (p) return p;
      return { lat: map3d.center.lat, lng: map3d.center.lng, name: "center" };
    }

    function placeSelectedModel() {
      const sel = $("modelSelect");
      if (!sel) {
        setStatus("modelSelect ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        return;
      }

      const opt = sel.options[sel.selectedIndex];
      const id = sel.value;
      const file = opt?.dataset?.file;

      console.log("[model] selected:", { id, file, Model3DElement });

      if (!id || !file) {
        setStatus("ãƒ¢ãƒ‡ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“");
        return;
      }
      if (!Model3DElement) {
        setStatus("Model3DElement ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆmaps3då¯¾å¿œã‚’ç¢ºèªï¼‰");
        return;
      }

      const place = getPlaceFromPromptOrCenter();

      // â˜…URLã‚’å¿…ãšç›¸å¯¾ãƒ‘ã‚¹ã§
      const src = `./gltf/${file}`;

      const scale = Number(opt.dataset.scale) || 3;

      // â˜…è¦‹å¤±ã„é˜²æ­¢ï¼šä¸€æ—¦ã‚«ãƒ¡ãƒ©ã‚’å¯„ã›ã‚‹ï¼ˆrangeã‚’å°ã•ãï¼‰
      setCamera({
        center: { lat: place.lat, lng: place.lng, altitude: 300 },
        range: 1200,
        tilt: 65,
        heading: 30
      });

      // â˜…Undoç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹ï¼ˆå¿…è¦ãªã‚‰ï¼‰
      currentGroup = [];
      renderedGroups.push(currentGroup);

      const model = new Model3DElement({
        src,
        position: { lat: place.lat, lng: place.lng, altitude: 0 },
        scale,
        orientation: { tilt: -90, heading: 0, roll: 0 },
        altitudeMode: AltitudeMode.RELATIVE_TO_GROUND
      });

      map3d.append(model);
      currentGroup.push(model);

      setStatus(`ãƒ¢ãƒ‡ãƒ«é…ç½®: ${id} (${file})`);
    }

    function ensureGroup() {
      // ã€Œç”Ÿæˆã€å˜ä½ã§Undoã—ãŸã„ãªã‚‰ã€é…ç½®ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹
      currentGroup = [];
      renderedGroups.push(currentGroup);
    }

    function placeModelFromManifest(modelMeta) {
      if (!modelMeta) {
        setStatus("ãƒ¢ãƒ‡ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“");
        return;
      }
      if (!map3d) return;

      // maps3d ã®ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†ï¼ˆimportLibrary ã§å–ã£ã¦ã‚‹å‰æï¼‰
      const Model3DElementCtor =
        (google.maps?.maps3d?.Model3DElement) || window.Model3DElement;

      if (!Model3DElementCtor) {
        setStatus("Model3DElement ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆmaps3dã®å¯¾å¿œã‚’ç¢ºèªï¼‰");
        return;
      }

      const place = getPlaceFromPromptOrCenter();

      // URLã¯å¿…ãšHTTPã§é…ä¿¡ã•ã‚Œã‚‹ç›¸å¯¾ãƒ‘ã‚¹ã«ã™ã‚‹
      const src = `./gltf/${modelMeta.file}`;

      // ã‚¹ã‚±ãƒ¼ãƒ«ã¯ manifest å„ªå…ˆï¼ˆãªã‘ã‚Œã°é©å½“ã«ï¼‰
      const scale = Number.isFinite(modelMeta.scale) ? modelMeta.scale : 60;

      // ã“ã“ã§Undoã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹ï¼ˆãƒ¢ãƒ‡ãƒ«å˜ç™ºã§ã‚‚ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰
      ensureGroup();

      const model = new Model3DElementCtor({
        src,
        position: { lat: place.lat, lng: place.lng, altitude: 0 },
        scale,
        orientation: { tilt: -90, heading: 0, roll: 0 },
        altitudeMode: AltitudeMode.RELATIVE_TO_GROUND
      });

      map3d.append(model);
      currentGroup.push(model);

      // ã‚«ãƒ¡ãƒ©ã‚‚ãã®å ´æ‰€ã¸å¯„ã›ã‚‹ï¼ˆå¿…è¦ãªã‚‰Flyã«ã—ã¦ã‚‚OKï¼‰
      setCamera({
        center: { lat: place.lat, lng: place.lng, altitude: 300 },
        range: 1500,
        tilt: 65,
        heading: 30
      });

      setStatus(`ãƒ¢ãƒ‡ãƒ«é…ç½®: ${modelMeta.label ?? modelMeta.id}`);
    } 

  </script>
</body>
</html>
